name: Build Win32 tdjson.dll (EasierLanguage Compatible)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:  # 支持手动触发，方便重试

jobs:
  build:
    runs-on: windows-latest
    env:
      VCPKG_ROOT: 'C:\vcpkg'       # vcpkg固定路径
      BUILD_DIR: 'build32'         # 32位构建目录
      VCPKG_TAG: '2024.09.12'      # 稳定vcpkg版本，避免依赖波动

    steps:
      # 1. 检出TDLib完整源码（含子模块，确保有CMakeLists.txt）
      - name: 检出TDLib源码
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'  # 关键：拉取TDLib依赖的子模块，避免源码缺失

      # 2. 缓存vcpkg依赖（首次安装后，后续直接复用，节省10+分钟）
      - name: 缓存vcpkg依赖
        uses: actions/cache@v3
        id: cache-vcpkg
        with:
          path: |
            ${{ env.VCPKG_ROOT }}
            !${{ env.VCPKG_ROOT }}/buildtrees  # 排除临时构建文件，减小缓存体积
            !${{ env.VCPKG_ROOT }}/downloads   # 排除安装包，避免重复下载
          key: vcpkg-x86-${{ env.VCPKG_TAG }}-${{ hashFiles('**/vcpkg.json') }}  # 按版本+依赖文件哈希缓存
          restore-keys: vcpkg-x86-${{ env.VCPKG_TAG }}-  # 缓存未命中时，回退到同版本最近缓存

      # 3. 仅缓存未命中时，安装依赖工具和vcpkg
      - name: 安装gperf工具（TDLib编译依赖）
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: choco install gperf -y  # -y自动确认安装，无需交互

      - name: 初始化vcpkg（仅首次执行）
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: |
          git clone https://github.com/microsoft/vcpkg.git $env:VCPKG_ROOT
          git -C $env:VCPKG_ROOT checkout tags/$env:VCPKG_TAG  # 切换到固定版本
          & "$env:VCPKG_ROOT\bootstrap-vcpkg.bat"  # 初始化vcpkg工具链

      - name: 安装32位依赖（OpenSSL + zlib，TDLib核心依赖）
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: vcpkg install openssl[core]:x86-windows zlib:x86-windows --clean-after-build
        env:
          VCPKG_DEFAULT_TRIPLET: x86-windows  # 显式指定32位目标平台

      # 4. 缓存CMake编译产物（首次编译后，后续跳过编译，1分钟内完成）
      - name: 缓存CMake构建产物
        uses: actions/cache@v3
        id: cache-build
        with:
          path: ${{ env.BUILD_DIR }}  # 缓存整个build32目录（含编译中间文件）
          key: cmake-build-win32-${{ github.sha }}  # 按代码提交哈希缓存（源码变才重新编译）
          restore-keys: cmake-build-win32-  # 回退到同分支最近编译缓存

      # 5. 配置+编译tdjson.dll（核心步骤，超时延长至45分钟）
      - name: 配置+编译tdjson.dll（支持易语言stdcall）
        if: steps.cache-build.outputs.cache-hit != 'true'
        run: |
          mkdir -p $env:BUILD_DIR  # 创建构建目录（不存在则创建）
          cd $env:BUILD_DIR       # 进入构建目录
          # 单行CMake命令：避免换行解析错误，明确指定源码目录为".."（build32的上一级）
          cmake -G "Visual Studio 17 2022" -A Win32 -DCMAKE_TOOLCHAIN_FILE="${{ env.VCPKG_ROOT }}\scripts\buildsystems\vcpkg.cmake" -DCMAKE_BUILD_TYPE=Release "-DTD_JSON_CLIENT_API=__declspec(dllexport) __stdcall" ..
          # 4核心并行编译（平衡速度与稳定性，适配Runner资源）
          cmake --build . --config Release --parallel 4
        timeout-minutes: 45  # 关键：延长超时至45分钟，覆盖首次编译耗时

      # 6. 验证编译结果（确保tdjson.dll生成，避免空产物）
      - name: 验证tdjson.dll是否生成
        run: |
          if (-not (Test-Path "$env:BUILD_DIR\Release\tdjson.dll")) {
            throw "编译失败：核心文件tdjson.dll未生成，请检查日志"
          }

      # 7. 复制依赖DLL（将OpenSSL/zlib复制到输出目录，方便易语言直接使用）
      - name: 复制依赖DLL到输出目录
        run: |
          $vcpkgBinPath = "${{ env.VCPKG_ROOT }}\installed\x86-windows\bin"  # vcpkg依赖DLL路径
          $outputPath = "$env:BUILD_DIR\Release"                            # 输出目录
          # 复制3个必需依赖
          Copy-Item "$vcpkgBinPath\libcrypto-3.dll" -Destination $outputPath -Force
          Copy-Item "$vcpkgBinPath\libssl-3.dll" -Destination $outputPath -Force
          Copy-Item "$vcpkgBinPath\zlib1.dll" -Destination $outputPath -Force
          # 打印文件列表，确认复制成功
          Write-Host "输出目录DLL列表："
          Get-ChildItem $outputPath -Filter *.dll | Select-Object Name

      # 8. 上传最终产物（打包tdjson.dll+所有依赖，方便下载使用）
      - name: 上传tdjson.dll及依赖
        uses: actions/upload-artifact@v4
        with:
          name: tdjson-win32-stdcall  # 压缩包名称（清晰标识平台和调用约定）
          path: ${{ env.BUILD_DIR }}/Release/*.dll  # 上传所有DLL
          retention-days: 7  # 产物保留7天，按需调整（如需要长期保留可改30）
